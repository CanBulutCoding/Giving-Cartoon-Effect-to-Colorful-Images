# -*- coding: utf-8 -*-
"""assignment.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uWm74ADCIRMsWKqSbQbrI3LlLhmoHSRT
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.ndimage import gaussian_filter, median_filter
from PIL import Image
from skimage.color import rgb2lab, lab2rgb
from sklearn.cluster import KMeans
from scipy.ndimage import binary_opening
from skimage.color import rgb2lab, rgb2hsv, lab2rgb, hsv2rgb

# You can change the input image from here
input_file = "img1.jpeg"


# Part 1: Image Smoothing
def load_image(file_path):
    return np.array(Image.open(file_path))

def apply_median_filter(image, size):
    return median_filter(image, size=(size, size, 1))

def visualize_smoothing(input_path, output_path, gaussian_sigma_values, median_sigma_values):
    # Load the image
    input_image = load_image(input_path)

    # Display the original image
    plt.figure(figsize=(8, 8))
    plt.subplot(4, 1, 1)
    plt.imshow(input_image)
    plt.title('Original')
    plt.axis('off')

    # Apply Gaussian filters with different sigma values
    smoothed_images = []
    for i, sigma in enumerate(gaussian_sigma_values):
        smoothed_gaussian = gaussian_filter(input_image, sigma=(sigma, sigma, 0))
        smoothed_images.append(smoothed_gaussian)
        plt.subplot(4, len(gaussian_sigma_values), len(gaussian_sigma_values) + i + 1)
        plt.imshow(smoothed_gaussian)
        plt.title(f'Gaussian, Sigma={sigma}')
        plt.axis('off')

    # Apply Median filters with different sigma values
    for i, sigma in enumerate(median_sigma_values):
        smoothed_median = apply_median_filter(input_image, int(2 * sigma) + 1)
        plt.subplot(4, len(median_sigma_values), 2 * len(median_sigma_values) + i + 1)
        plt.imshow(smoothed_median)
        plt.title(f'Median, Sigma={sigma}')
        plt.axis('off')

    # Save the result
    plt.tight_layout()
    plt.savefig(output_path + '_smoothing.png')
    plt.show()

    return smoothed_images


# YOU CAN CHANGE THE PARAMETERS FROM HERE

gaussian_sigma_values = [2.0, 4.0, 8.0] # You can try out different sigma values for gaussian filter
median_sigma_values = [2, 4, 8]      # You can try out different sigma values for median filter

# Example usage for image smoothing
smoothed_images = visualize_smoothing(input_file, "output_smoothing_comparison", gaussian_sigma_values, median_sigma_values)

# Part 2: Edge Detection

def apply_difference_of_gaussian(image, sigma1, sigma2):
    grayscale_image = np.mean(image, axis=-1)  # Convert to grayscale
    gaussian1 = gaussian_filter(grayscale_image, sigma=sigma1)
    gaussian2 = gaussian_filter(grayscale_image, sigma=sigma2)
    dog = gaussian1 - gaussian2
    return dog

def apply_threshold(image, threshold):
    return np.where(image >= threshold, 1, 0)

def visualize_edge_detection(input_images, output_path, sigma1_1, sigma2_1, sigma1_2, sigma2_2, thresholds):
    # Load the smoothed images from the first part
    smoothed_image = input_images[0]

    # Display only the thresholded images for different threshold values
    plt.figure(figsize=(12, 4 * len(thresholds)))

    # Display images for different threshold values
    for i, threshold in enumerate(thresholds):
        # Apply Difference of Gaussian for the first set of sigma values
        dog_image_1 = apply_difference_of_gaussian(smoothed_image, sigma1_1, sigma2_1)
        # Apply Threshold for the first set of sigma values
        thresholded_image_1 = apply_threshold(dog_image_1, threshold)

        # Apply Difference of Gaussian for the second set of sigma values
        dog_image_2 = apply_difference_of_gaussian(smoothed_image, sigma1_2, sigma2_2)
        # Apply Threshold for the second set of sigma values
        thresholded_image_2 = apply_threshold(dog_image_2, threshold)

        # Display the thresholded images
        plt.subplot(len(thresholds), 2, 2 * i + 1)
        plt.imshow(thresholded_image_1, cmap='gray')
        plt.title(f'Thresholded (Sigma1={sigma1_1}, Sigma2={sigma2_1}, Threshold={threshold})')
        plt.axis('off')

        plt.subplot(len(thresholds), 2, 2 * i + 2)
        plt.imshow(thresholded_image_2, cmap='gray')
        plt.title(f'Thresholded (Sigma1={sigma1_2}, Sigma2={sigma2_2}, Threshold={threshold})')
        plt.axis('off')

    # Save the result
    plt.tight_layout()
    plt.savefig(output_path + '_edge_detection.png')
    plt.show()

# YOU CAN CHANGE THE PARAMETERS FROM HERE

k = 2 # You can change the k value from the first equation
sigma1_edge_1 = 2.0   # First sigma value from the first equation
sigma2_edge_1 = sigma1_edge_1 * k  # Second sigma value from the first equation
thresholds = [2, 4, 8] # You can try outt different threshold values from the third equation

# This is purely for comparing how k value changes edge detection
k = 3
sigma1_edge_2 = 2.0
sigma2_edge_2 = sigma1_edge_2 * k


# Example usage for edge detection with different sigma values and threshold values
visualize_edge_detection(smoothed_images, "output_edge_detection", sigma1_edge_1, sigma2_edge_1, sigma1_edge_2, sigma2_edge_2, thresholds)

# Part 3: Color Quantization

def quantize_colors_lab(image, num_colors):
    # Convert the image to Lab color space
    lab_image = rgb2lab(image)

    # Extract the Luminance channel for quantization
    luminance_channel = lab_image[:, :, 0]

    # Quantize the Luminance channel
    quantized_luminance = np.round(luminance_channel * (num_colors - 1) / 100) * (100 / (num_colors - 1))

    # Replace the original Luminance channel with the quantized one
    lab_image[:, :, 0] = quantized_luminance

    # Convert the image back to RGB color space
    quantized_image_lab = lab2rgb(lab_image)

    return quantized_image_lab

def quantize_colors_hsv(image, num_colors):

    # Convert the image to HSV color space
    hsv_image = rgb2hsv(image)

    # Extract the Value channel for quantization
    value_channel = hsv_image[:, :, 2]

    # Quantize the Value channel
    quantized_value = np.round(value_channel * (num_colors - 1) / 1) * (1 / (num_colors - 1))

    # Replace the original Value channel with the quantized one
    hsv_image[:, :, 2] = quantized_value

    # Convert the image back to RGB color space
    quantized_image_hsv = hsv2rgb(hsv_image)

    return quantized_image_hsv


def visualize_color_quantization(smoothed_images, output_path, num_colors_values, smoothed_image_index):
    # Load the best smoothed image from the first part
    smoothed_image = smoothed_images[smoothed_image_index]

    plt.figure(figsize=(12, 8 * len(num_colors_values)))

    # Display the original smoothed image
    plt.subplot(len(num_colors_values) + 1, 1, 1)
    plt.imshow(smoothed_image)
    plt.title('Smoothed Image')
    plt.axis('off')

    for i, num_colors in enumerate(num_colors_values):
        # Perform color quantization for Lab color space
        quantized_image_lab = quantize_colors_lab(smoothed_image, num_colors)

        # Display the quantized image for Lab color space
        plt.subplot(len(num_colors_values) + 1, 2, 2 * i + 3)
        plt.imshow(quantized_image_lab)
        plt.title(f'Lab Quantized (Num Colors={num_colors})')
        plt.axis('off')

        # Perform color quantization for HSV color space
        quantized_image_hsv = quantize_colors_hsv(smoothed_image, num_colors)

        # Display the quantized image for HSV color space
        plt.subplot(len(num_colors_values) + 1, 2, 2 * i + 4)
        plt.imshow(quantized_image_hsv)
        plt.title(f'HSV Quantized (Num Colors={num_colors})')
        plt.axis('off')

    # Save the result
    plt.tight_layout()
    plt.savefig(output_path + '_color_quantization.png')
    plt.show()


# YOU CAN CHANGE THE PARAMETERS FROM HERE

num_colors_values = [8,16]    # You can try out different num_colors values for both Lab and HSV
smoothed_image_index = 0      # You can try out different smoothed images from the first part


# Example usage for color quantization with Lab and HSV color spaces
visualize_color_quantization(smoothed_images, "output_color_quantization", num_colors_values, smoothed_image_index)

# Part 4: Combining Edge and Quantized Image

def combine_edges_and_quantized(edges, quantized_image):
    # Take the inverse of the edges
    inverted_edges = 1 - edges

    # Multiply the inverted edges with the quantized image for each channel
    combined_image = quantized_image * inverted_edges[:, :, np.newaxis]

    return combined_image

def visualize_combined_image(input_image, edges, quantized_image, output_path):

    plt.figure(figsize=(8, 12))

    # Display the original input image
    plt.subplot(2, 1, 1)
    plt.imshow(input_image)
    plt.title('Original Input Image')
    plt.axis('off')

    # Display the combined image
    combined_image = combine_edges_and_quantized(edges, quantized_image)
    plt.subplot(2, 1, 2)
    plt.imshow(combined_image)
    plt.title('Cartoon Image')
    plt.axis('off')

    # Save the result
    plt.tight_layout()
    plt.savefig(output_path + '_combined_image.png')
    plt.show()

# Load the original input image
input_image = load_image(input_file)

# YOU CAN CHANGE THE PARAMETERS FROM HERE

smoothed_image_index = 0   # This is from the first part where we created 6 different smoothed images using different sigma values with gaussian and median filter
k = 2                      # k value from the second part
sigma_1 = 2                # First sigma value from the second part
sigma_2 = sigma_1 * k      # Second sigma value from the second part
threshold = 20             # Threshold value from the second part
num_colors = 8             # num_colors value from the third part

# Threshold the edges
thresholded_edges = apply_threshold(apply_difference_of_gaussian(smoothed_images[smoothed_image_index], sigma_1, sigma_2), threshold)

# Load the quantized image from part 3 (HSV)
quantized_image_hsv = quantize_colors_hsv(smoothed_images[smoothed_image_index], num_colors)

# Visualize the combined image
visualize_combined_image(input_image, thresholded_edges, quantized_image_hsv, "output_combined_image")